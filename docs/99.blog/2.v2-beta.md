---
date: 2024-06-02
category: release
authors:
  - name: Pooya Parsa
    github: pi0
---

# H3 v2-beta - Try now!

> H3 v2-beta is finally ready to try, coming with a full rewrite based on Web standards, backward compatibility, and a big perf boost!

H3 was born ~5 years ago in late 2020, during the rise of edge Workers. Since earlier versions of H3, using [unjs/unenv](https://github.com/unjs/unenv) and [Nitro](https://nitro.build), allowed H3 apps to run directly in worker runtimes and since [v1.8](/blog/v1.8), H3 increased Web standard compatibility support.

H3 v1 remained based on Node.js APIs with a compatibility layer for Web standards. This was the logical choice because even today, Node.js is mostly used runtime for JavaScript servers.

Thanks to the evolution of Web standards, and wider support in runtimes such as [Deno](https://deno.com/), [Bun](https://bun.sh/), also the latest [Node.js](https://nodejs.org/en), i feel confident that ecosystem is finally ready to best on the Web standards for Servers. This has several benefits:

- ‚úÖ Cross-Runtime interoperability (Node.js, Deno, Bun, Workers, etc)
- ‚úÖ Cross-FrameWork compatibility (Hono, Elysia, etc)
- ‚úÖ Cross-Environment compatibility (Closer code used in Frontend and Backend)
- ‚úÖ Easier to test server APIs

## Srvx: Universal Server API

The first challenge for adopting Web standards, was that Node.js does not natively support creating HTTP servers with Web Platform APIs. It means an "adapter" is needed to convert [`node.http.IncomingMessage`](https://nodejs.org/api/http.html#class-httpincomingmessage) to web [Request](https://developer.mozilla.org/en-US/docs/Web/API/Request) and handle [Response](https://developer.mozilla.org/en-US/docs/Web/API/Response) via [`node.http.SeeverResponse`](https://nodejs.org/api/http.html#class-httpserverresponse). There are several existing attempts for this compatibility layer, but during evaluation, none of them fit exactly what was needed for H3 in terms of modularity, performance, and compatibility.

Furthormore, each runtime that pioneered in adopting Web standards for servers did not agreed on the same specifics.
Commonly, all new server runtimes accept [`fetch`](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)-like handler with [Request](https://developer.mozilla.org/en-US/docs/Web/API/Request) as input and a [Response](https://developer.mozilla.org/en-US/docs/Web/API/Response) as returned value. However, since Web standards were not initially designed to be used in the Servers context, they lack standards for accessing request context and IP. WebSocket upgrades, setting server options, etc. So each runtime made their own addons (Today, [WinterTC](https://wintertc.org/faq)'s mission is to increase cross-runtime interoperability, hopefully over time).

We have built a robust and open abstraction layer "[srvx](https://srvx.h3.dev)" during development of H3 version 2.

Srvx project has one primary job to do well ([Unix Philosophy](http://www.catb.org/esr/writings/taoup/html/ch01s06.html)): **Unify Javascript Server APIs**.

```js
// Works with Deno, Bun, Node.js, Service Workers and Edge
import { serve } from "srvx";

serve({
  port: 3000,
  fetch(request) {
    // request.ip
    // request.runtime?.{bun,deno,node,cloudflare,...}
    return new Response("üëã Hello there!");
  },
});
```

> [!NOTE]
> One distinct choice in srvx, is that all runtime specific addons are added under the `request.runtime?` instead of needing to carry one or more extra context objects.

With srvx as the new building block layer handling all necessary runtime-specific API mappings, H3 can be significantly simpler and focus on only Web platform APIs, yet supporting any runtime of your choice with best performance ([benchmarks](https://github.com/h3js/srvx/tree/main/test/bench-node)) and compatibility assured with same tests passing in all supported adapters. We will likely backport more custom runtime and provider adapters to the srvx layer in the future.

## H3: Tiny Server Composer üé∂

With the full adoption of Web Platform APIs and srvx already handling cross runtime differences, I wanted to make sure the H3 scope remains as simple as possible. In fact, making it Simple was the [most complex](https://www.antonsten.com/articles/simple-is-hard/) part and took months until finding the right balance between minimal and usability with conventions.

```js
import { H3, serve } from "h3";

const app = new H3().get("/", () => "‚ö°Ô∏è Tadaa!");

serve(app, { port: 3000 });
```

With H3, you have:

- ‚úÖ A web server based on unified Web standards (handling low-level performance optimizations).
- ‚úÖ Easy responses and error handling by directly returning or throwing whatever you want.
- ‚úÖ Routing support with a tiny and fast router ([rou3](https://github.com/h3js/rou3)).
- ‚úÖ Middleware to intercept requests, responses, and errors.
- ‚úÖ Tiny core and composable utilities.

## Web-Compatible Event Context

H3 version 2 is not only built on top of Web Platform APIs, but also trying to strongly embrace them and avoiding any additional convention when possible.

With each HTTP request, an `H3Event` context is passed to handlers and middleware, which you can access.

```js
app.any("/**", (event) => {
    // Access to parsed request URL
  // üöÄ Faster than new URL(req.url)
  const { pathname } = event.url;

  // Access to incoming Request
  const accept = event.req.headers.get("Accept");

  // Access to request body
  const bodyStream = await event.req.body;
  const bodyText = await event.req.text();
  const bodyJSON = await event.req.json();
  const bodyFormData = await event.req.fromData();

  // Access to runtime specific context
  const { deno, bun, node } = event.req.runtime;

  // Set response headers
  event.res.headers.set("Content-Type", "application/json");

  // Send Web standard response
  return Response.json({ hello: "web" });
});
```

## Chainable Middleware

One of the frequently requested features was an ergonomic way to intercept the request lifecycle. While H3 supports global hooks such as `onRequest`, `onBeforeResponse`, and `onError`, they are not composable enough.

Following up good experiences from [srvx middleware](https://srvx.h3.dev/guide/middleware) and inspired by [Hono middleware](https://hono.dev/docs/guides/middleware) üíõ, H3 recently introduced a new chainable middleware API.

```js
import { H3, serve } from "h3";

const app = new H3();

app.use("/", async (event, next) => {
  // Intercept incoming requests
  console.log(`[${event.req.method}] ${event.req.url}`);

  // Wait for final response
  const rawResponse = await next();

  // Append headers
  event.res.headers.push("x-middleware", "works");

  // Let H3 handle the response
  return rawResponse;
});
```

> [!NOTE]
> Using `next()` function is optional. You can omit it from handler params and keep using middleware like v1 without returning a value.

## Bare-Metal Performances

One classic approach to qualify web frameworks is by comparing RPS (Requests Per Second). This method to measure RPS, often can be misleading to read and also contains external factors such as OS networking layer and runtime specific behavior, and does not take into account about other factors like bundle size and initialization time that matter.

We have approached benchmarking with a new system that primarily focused on measuring how much overhead framework itself adds and try to minimize all factors closer to zero, as if you have not added or used H3.

- Response generation latency (`app.fetch(request)`)
- App initialization time (important for short-lived servers)
- App bundle size (without runtime adapters)

Thanks to the clarity of this new method, H3 latency could be optimized with precision of ¬µs per request (10<sup>-6</sup> of a second!) and bundle size down to bytes, leading to H3 v2 being significiantly better than previous versions.

> [!NOTE]
> It is worth noting that, at this level, any web-compatible framework you choose (or even if you combine multiple of them!) barely affects final performances in your applications (network latency is usually measured in scale of milliseconds). These kinds of benchmarks are purely for internal low-level optimizations.

[TODO: results comparing with v1]

## Migration from Version 1

Even though H3 version 2 is an almost full rewrite, we tried to reduce the impact of breaking changes.

::read-more{to="/migration"}
Check out [Migration Guide](/migration) for API changes.
::

## Unified H(ttp) Server Tools

H3 and related projects recently migrated from [UnJS](https://github.com/unjs), which served as an incubator, into a new [Github org](https://github.com/h3js), team and domain [h3.dev](https://h3.dev).

Under the umbrella of H3, we are maintaining several key components for universal JavaScript servers, all completely open to be used with or without H3 and with any JavaScript runtime.

- [‚ö°Ô∏è h3](https://github.com/h3js/h3): Minimal H(TTP) framework.
- [üå≥ rou3](https://github.com/h3js/rou3): Lightweight and fast rou(ter) for JavaScript.
- [üí• srvx](https://srvx.h3.dev): Universal Server API based on Web standards.
- [üîå srvx](https://crossws.h3.dev): Cross-platform WebSocket server.

## Roadmap to v2 stable

We will be trying to improve documentation, update examples, gather more feedback, testing H3 version 2 for possible bugs and do last minute cleanups with possible slight API changes and make sure compatibility is good enough for wider ecosystem adoption by beta testing against [Nitro](https://nitro.build) v3.

You can join our new [Discord](https://discord.h3.dev) server to chat, and can't wait to hear how is your experience with H3 version 2!
