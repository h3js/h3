---
date: 2024-06-02
category: release
authors:
  - name: Pooya Parsa
    github: pi0
---

# H3 v2-beta - Try it now!

> H3 v2-beta is finally ready to try, featuring a complete rewrite based on Web standards, backward compatibility, and a significant performance boost!

H3 was born around five years ago in late 2020, during the rise of edge Workers. Early H3 versions, using [unjs/unenv](https://github.com/unjs/unenv) and [Nitro](https://nitro.build), allowed H3 apps to run directly in worker runtimes. Since [v1.8](/blog/v1.8), H3 has enhanced its Web standards compatibility.

H3 v1 was primarily based on Node.js APIs with a compatibility layer for Web standards. Logical choice at the time, given Node.js's popularity amongst JavaScript server runtimes.

Thanks to evolving Web standards and improved runtime support (such as [Deno](https://deno.com/), [Bun](https://bun.sh/), and the latest [Node.js](https://nodejs.org/en)), the ecosystem is now ready to fully embrace Web standards for server development. Benefits include:

- ‚úÖ Cross-runtime interoperability (Node.js, Deno, Bun, Workers, etc.)
- ‚úÖ Cross-framework compatibility (Hono, Elysia, etc.)
- ‚úÖ Cross-environment compatibility (shared frontend and backend code)
- ‚úÖ Easier server API testing

## Srvx: Universal Server API

A major challenge is that Node.js lacks native support for Web-standard HTTP servers. Adapters are needed to bridge `node.http.IncomingMessage` to `Request`, and to handle `Response` via `node.http.ServerResponse`. As existing adapters did not fully meet H3's requirements, We have implemented a [compatibility layer](https://srvx.h3.dev/guide/node) that synchronizes interfaces and achieves up to **90%** of `node:http` performance. Almost the best in class for performances today comparing to alternatives (see [benchmarks](https://github.com/h3js/srvx/tree/main/test/bench-node)).

Furthermore, each runtime that pioneered adopting Web standards for servers did not agree on specific implementation details. Typically, all new server runtimes accept a [`fetch`](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)-like handler, using [Request](https://developer.mozilla.org/en-US/docs/Web/API/Request) as input and returning a [Response](https://developer.mozilla.org/en-US/docs/Web/API/Response). However, since Web standards were not initially designed for server contexts, they lack standardized ways to access request context, IP information, handle WebSocket upgrades, or set server options. Consequently, each runtime created its own extensions. Today, initiatives like [WinterTC](https://wintertc.org/faq) aim to establish cross-runtime interoperability over time.

We created [üí• srvx](https://srvx.h3.dev) out of H3 development branch: An open, robust abstraction layer aiming to unify JavaScript server APIs:

```js
// Compatible with Deno, Bun, Node.js, Service Workers, and Edge
import { serve } from "srvx";

serve({
  port: 3000,
  fetch(req) {
    // req.url, req.ip, req.waitUntil, req.runtime?.{bun,deno,node,cloudflare,...}
    return new Response("üëã Hello there!");
  },
});
```

> [!NOTE]
> Srvx encapsulates runtime-specific addons under `request.runtime?`, avoiding extra context objects to be passed around.

With srvx handling runtime-specific API mappings, H3 can remain simpler, focusing exclusively on Web APIs while ensuring cross-runtime performance and compatibility from srvx.

## H3: Tiny Server Composer üé∂

Adopting Web APIs and leveraging [üí• srvx](https://srvx.h3.dev) simplified H3‚Äôs scope significantly.

- ‚úÖ A Web-standard server optimized for performance.
- ‚úÖ Simple and typed responses and error handling (return or throw directly).
- ‚úÖ Fast routing via the tiny router ([üå≥ rou3](https://github.com/h3js/rou3)).
- ‚úÖ Middleware for request, response, and error interception.
- ‚úÖ Tiny core and composable utilities.

```js
import { H3, serve } from "h3";

const app = new H3().get("/", () => "‚ö°Ô∏è Tadaa!");

serve(app, { port: 3000 });
```

## Web-Compatible Event Context

H3 v2 fully embraces Web Platform APIs, minimizing additional conventions in context API.

```js
app.any("/**", async (event) => {
  const { pathname } = event.url; // Fast URL parsing
  const accept = event.req.headers.get("Accept");

  const bodyStream = await event.req.body;
  const bodyText = await event.req.text();
  const bodyJSON = await event.req.json();
  const bodyFormData = await event.req.formData();

  const { deno, bun, node } = event.req.runtime;

  event.res.headers.set("Content-Type", "application/json");

  return { hello: "web" };
});
```

## Chainable Middleware

H3 now offers an ergonomic, composable way to chain middleware using `next()` function inspired by [Hono middleware](https://hono.dev/docs/guides/middleware) üíõ:

```js [global middleware]
import { H3 } from "h3";

const app = new H3().use(async (event, next) => {
  // ... before response ...
  const body = await next();
  // ... after response ...
  event.res.headers.append("x-middleware", "works");
  event.waitUntil(sendMetrics(event));
  return body;
});
```

```js [handler middleware]
import { defineEventHandler, basicAuth } from "h3";

export default defineEventHandler({
  middleware: [basicAuth({ password: "test" })],
  handler: (event) => `Hello ${event.context.basicAuth?.username}!`,
});
```

```js [onRequest]
import { H3, onRequest } from "h3";

const app = new H3().use(
  onRequest((event) => {
    console.log(`Request: [${event.req.method}] ${event.url.pathname}`);
  }),
);
```

```js [onResponse]
import { H3, onResponse } from "h3";

const app = new H3().use(
  onResponse((event, { body }) => {
    console.log(`Response: [${event.req.method}] ${event.url.pathname}`, body);
  }),
);
```

```js [onError]
import { H3, onError } from "h3";

const app = new H3().use(
  onError((event, error) => {
    console.error(
      `[${event.req.method}] ${event.url.pathname} !! ${error.message}`,
    );
  }),
);
```

> [!NOTE]
> Using `next()` is optional. Middleware can be written like v1 without returning a response.

## Bare-Metal Performance

One classic way to evaluate web frameworks is by comparing RPS (Requests Per Second). However, this metric can be misleading, as it is influenced by external factors such as the OS networking layer and runtime-specific behavior. It also overlooks other important aspects like bundle size and initialization time.

We approached benchmarking with a new system that focuses on measuring the overhead introduced by the framework itself. Our goal is to optimize all relevant measurements together, making it as close as possible to a baseline where H3 is not added or used: Response latency (`app.fetch(request)`), App initialization speed and Bundle size of minimal app.

This method, allowed H3 v2 to have optimized latency improvements per request and dramatically smaller core bundle size. We also made a brand-new tiny router ([üå≥ rou3](https://github.com/h3js/rou3)) based on this new metrics.

| Measurement      | H3 v1                                      | üöÄ H3 v2                                                                                      |
| ---------------- | ------------------------------------------ | --------------------------------------------------------------------------------------------- |
| Request Handling | Node: 36 ¬µs <br> Bun: 27 ¬µs <br> Deno 7 ms | Node: 7 ¬µs (**5x faster**) <br> Bun: 3 ¬µs (**9x faster**) <br> Deno: 1.2 ¬µs (**156x faster**) |
| App Bundle Size  | min: 101 kB <br> min+gzip: 39.6 kB         | min: 9,1 kB (**91% smaller**) <br> min+gzip: 3.6 kB (**90% smaller**)                         |

> [!NOTE]
> The benchmarks above compare the H3 core using the **Web Standard** target and do not include adapters. They are intended primarily for internal optimization purposes. See the [benchmark sources](https://github.com/h3js/h3/tree/main/test/bench) for details.

> [!TIP]
> New request handling times are nearly equivalent to (sometimes faster than) using plain `fetch` and `new URL(req.url).pathname` for routing.

## Migration from Version 1

We've minimized breaking changes.

::read-more{to="/migration"}
Check out new v2 [Migration Guide](/migration).
::

## Unified H(ttp) Server Tools

H3 and related projects moved to a dedicated [Github org](https://github.com/h3js) and [h3.dev](https://h3.dev) domain.

Under the H3 umbrella, we maintain several key components for universal JavaScript servers. All fully open and usable with or without H3, and with any JavaScript runtime.

- [‚ö°Ô∏è h3](https://github.com/h3js/h3): Minimal HTTP framework.
- [üå≥ rou3](https://github.com/h3js/rou3): Lightweight JavaScript router.
- [üí• srvx](https://srvx.h3.dev): Universal Web-based Server API.
- [üîå crossws](https://crossws.h3.dev): Cross-platform WebSocket server.

## ‚ù§Ô∏è Special Thanks

This release would not have been possible without wonderful [contributors](https://github.com/h3js/h3/graphs/contributors), feedback from the [community](https://discord.h3.dev), new runtimes including [Deno](https://deno.com/) and [Bun](https://bun.sh/), and Web-standard frameworks including [Hono](https://hono.dev/) and [Elysia](https://elysiajs.com/), which inspired many of the changes in this version of H3, as well as [sponsors](/#sponsors) who made it possible to work on open source.

## Roadmap to v2 Stable

Next steps:

- Improve documentation and update examples.
- Gather feedback and more testing.
- Refine APIs based on community feedback.
- Ensure ecosystem compatibility and adopt with [Nitro](https://nitro.build) v3.

::callout{to="https://discord.h3.dev"}
Join our [Discord](https://discord.h3.dev) to share your experience and feedback!
::
