---
title: Event Handlers
description: Define application logic and start building your server.
---

After [creating an app](/concepts/app), you can start defining your application logic using event handlers.

An event handler is a function that receive an [`Event`](/concepts/event) instance and returns a response. You can compare it to controllers in other frameworks.

## Defining Event Handlers

You can define event handlers using [`defineEventHandler`](/api/app/define-event-handler) or [`eventHandler`](/api/app/event-handler) utilities:

> [!NOTE]
> You can use [`eventHandler`](/api/app/event-handler) and [`defineEventHandler`](/api/app/define-event-handler) interchangeably. They are aliases. You can use the one you prefer but **stick to it** for consistency.

```js
import { defineEventHandler } from "h3";

defineEventHandler((event) => {
  return "Response";
});
```

The callback function can be sync or async:

```js
import { defineEventHandler } from "h3";

defineEventHandler(async (event) => {
  return "Response";
});
```

## Registering Event Handlers

Then, you can register event handlers to [App Instance](/concepts/app) using the [`use`](/api/app/create-app) method:

```js
app.use('/hello', defineEventHandler((event) => {
  return "Hello world!";
}));
```

This will register the event handler to the app instance and will be called for every request starting with the prefix `/hello`. This means that the event handler will be called for `/hello`, `/hello/world`, `/hello/123`, etc.

You can define multiple event handlers for the same route. H3 will try to to call them one by one in order of registration until one of them returns a response. This is called `stack runner`.

```js
app.use('/hello', defineEventHandler((event) => {
  return "First";
}));
app.use('/hello', defineEventHandler((event) => {
  return "Second";
}));
```

In this example, the first event handler will be called for every request starting with `/hello` and the second one will never be called.

However, if you do not return a response from the first event handler, the second one will be called:

```js
app.use('/hello', defineEventHandler((event) => {
  console.log("First");
  // No response returned
}));
app.use('/hello', defineEventHandler((event) => {
  return "Second";
}));
```

:read-more{to="/concepts/middleware"}

If all handlers get called and no response is returned, H3 will end the request with `404 - Not Found` status code.

> [!NOTE]
> Using an empty `return` will throw a `4040 - Not Found`. You must return a response, at least `null`.

## Options

The method `use` accepts an optional `options` object as third argument:

```js
app.use('/hello', defineEventHandler((event) => {
  return "Hello world!";
}), {
  // Options
});
```

:read-more{to="/utilities/define-event-handler"}

### Custom Mather

You can define a custom matcher function to have more advanced logic for matching requests but simple than a router.

For example, you can match only odd URLs, `/1`, `/3`, `/5`, etc.:

```js
app.use('/', defineEventHandler((event) => {
  return "Odd URLs only";
}), {
  match: (url) => {
    return url.substr(1) % 2;
  }
});
```

> [!WARNING]
> Do not use the custom matcher as a router. It is not designed for that purpose. Use a [router](/concepts/router) instead.

### Lazy

You can provide an async function that H3 will load on first time a request matching the route is received. It's useful for dynamic imports to reduce startup time.

```js
app.use('/big', () => import('./big-handler'), { lazy: true });
```

This reduce the startup time because the runtime have less code to load and parse when starting the server.

You can use a [syntax sugar](#lazy-event-handlers) over this option using [`defineLazyEventHandler`](/api/utilities/define-event-handler) or [`lazyEventHandler`](/api/utilities/event-handler) utilities.

## Throw Errors

If one of the handler throws an error, H3 will automatically catch it and end the request with `500 - Internal Server Error` status code.

```js
app.use('/hello', defineEventHandler((event) => {
  throw new Error("Something went wrong");
}));
```

You can easily control the error returned by using the utility [`createError`](/api/utilities/create-error):

```js
import { createError } from "h3";

app.use('/hello', defineEventHandler((event) => {
  throw createError({
    status: 400,
    message: "An error occured",
  });
}));
```

This will end the request with `400 - Bad Request` status code and the following JSON response:

```json
{
  "status": 400,
  "message": "An error occured"
}
```

:read-more{to="/api/utilities/create-error"}

## Object Syntax

You can use an object syntax in [`defineEventHandler`](/api/utilities/define-event-handler) to create more complexe logic:

```js
const auth = defineRequestMiddleware((event) => {
  event.context.auth = { name: 'admin' }
})

const log = defineResponseMiddleware((event) => {
  console.log(event.context.auth.name, event.node.req.url)
})

defineEventHandler({
  onRequest: [auth],
  onBeforeResponse: [log]
  handler(event) {
    // Called on every request
    return "Response";
  },
})
```

This can be useful to create reusable request and response [`middlewares`](/concepts/middleware).

:read-more{to="/api/utilities/define-event-handler"}

## Lazy Event Handlers

> [!NOTE]
> This is a syntax sugar over the [`lazy`](#lazy-matcher) option.

You can define lazy event handlers using [`defineLazyEventHandler`](/api/utilities/define-event-handler) or [`lazyEventHandler`](/api/utilities/event-handler) utilities. This allow you to define some one-time logic that will be executed only once when the first request matching the route is received.

A lazy event handler must return an event handler:

```js
import { defineLazyEventHandler } from "h3";

app.use(defineLazyEventHandler(() => {
  console.log("This will be executed only once");
  // This will be executed only once
  return defineEventHandler((event) => {
    // This will be executed on every request
    return "Response";
  });
}));
```

This is useful to define some one-time logic such as configuration, class initialization, heavy computation, etc.

## Responses Types

Values returned from event handlers are automatically converted to responses. It can be:

- JSON serializable value. If returning a JSON object or serializable value, it will be stringified and sent with default `application/json` content-type.
- `string`: Sent as-is using default `application/html` content-type.
- `null`: H3 with end response with `204 - No Content` status code.
- [Web `ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream) or [node `Readable`](https://nodejs.org/api/stream.html#readable-streams)
- [Web `ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) or [node `Buffer`](https://nodejs.org/api/buffer.html#buffer)
- [Web Fetch Response](https://developer.mozilla.org/en-US/docs/Web/API/Response/Response)
- [`Error`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error) instance. It's supported but **recommended** to throw errors instead of returning them using [`createError`](/api/utilities/create-error) utility.

Any of above values could also be wrapped in a [`Promise`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise). This means that you can return a `Promise` from your event handler and H3 will wait for it to resolve before sending the response.

### Examples

Send HTML response:

```js
app.use(eventHandler(async (event) => "<h1>Hello world!</h1>"));
```

Send JSON response:

```js
app.use(
  "/api",
  eventHandler(async (event) => ({ url: event.node.req.url })),
);
```

Send a promise:

```js
app.use(
  defineEventHandlers(async (event) => {
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve({ url: event.node.req.url });
      }, 1000);
    });
  }),
);
```
