---
icon: fluent:arrow-routing-20-regular
---

# Event Handlers

> Event handler defines application logic.

After creating an [H3 App Instance](/guide/app), you can start defining your application logic using event handlers.

An event handler is a function that receives an [H3Event](/guide/event) context and returns a response.

> [!TIP]
> See possible return values in [Response Types](#responses-types)

## Defining Handlers

You can define typed event handlers using `defineEventHandler`.

> [!NOTE]
> Using `defineEventHandler` is optional. When using [app methods](/guide/app#h3-methods) to register routes or middleware, the type hints will be still available.

```js
import { defineEventHandler } from "h3";

defineEventHandler((event) => "Response");
```

The callback function can be sync or async:

```js
defineEventHandler(async (event) => "Response");
```

You can optionally register some [middleware](#middleware) to run with event handler to intercept request, response or errors.

```js
defineEventHandler({
  middleware: [basicAuth({ password: "test" })],
  handler: (event) => "Hi!",
});
```

## Lazy Handlers

You can define lazy event handlers using `defineLazyEventHandler`. This allow you to define some one-time logic that will be executed only once when the first request matching the route is received.

A lazy event handler must return an event handler.

```js
import { defineLazyEventHandler } from "h3";

defineLazyEventHandler(async () => {
  await initSomething(); // Will be executed only once
  return (event) => {
    return "Response";
  };
});
```

This is useful to define some one-time logic such as configuration, class initialization, heavy computation, etc.

Another use-case is lazy loading route chunks:

```js [app.mjs]
import { H3, defineLazyEventHandler } from "h3";

const app = new H3();

app.all(
  "/route",
  defineLazyEventHandler(() =>
    import("./route.mjs").then((mod) => mod.default),
  ),
);
```

```js [route.mjs]
import { defineEventHandler } from "h3";

export default defineEventHandler((event) => "Hello!");
```

## Converting to H3 Handler

There are situations that you might want to convert an event handler or utility made for Node.js or another framework to h3.
There are built-in utils to do this.!

### Converting from Web Handlers

Request handlers with [Request](https://developer.mozilla.org/en-US/docs/Web/API/Request) => [Response](https://developer.mozilla.org/en-US/docs/Web/API/Response) syntax can be natively converted into H3 event handlers.

```js
import { H3, fromWebHandler } from "h3";

export const app = new H3();

const webHandler = (request) => new Response("ðŸ‘‹ Hello!"));

// Using fromWebHandler utiliy
app.get("/web", fromWebHandler(webHandler));

// Using simple wrapper
app.get("/web", event => webHandler(event.req));

// Using app.mount
app.mount("/web", webHandler)
```

:read-more{to="/guide/app#appmount" title="app.mount"}

### Converting from Node.js Handlers

If you have a legacy request handler with `(req, res) => {}` syntax made for Node.js, you can use `fromNodeHandler` to convert it to an h3 event handler.

> [!IMPORTANT]
> Node.js event handlers can only run within Node.js server runtime!

```js
import { H3, fromNodeHandler } from "h3";

// Force using Node.js compatibility (also works with Bun and Deno)
import { serve } from "h3/node";

export const app = new H3();

const nodeHandler = (req, res) => {
  res.end("Node handlers work!");
};

app.get("/web", fromNodeHandler(nodeHandler));
```

## Middleware

You can register global middleware using [`app.use`](/guide/app#appuse) to intercept requests. They can be used to add side effects to your application such as logging, caching, etc or to modify the request or response.

If you return a value from middleware, it will act as a normal event handler and sent it as response.

**Example:** Simple request logger.

```js [log.mjs]
app.use((event) => {
  console.log(`[${event.req.method}] ${event.req.url}`);
});
```

**Example:** Intercept responses.

```js [intercept.mjs]
app.use(async (event, next) => {
  const rawResponse = await next();
  return rawResponse;
});
```

You can define as much middleware as you need. They will be called in order of registration.

:read-more{to="/guide/routing#adding-middleware"}
