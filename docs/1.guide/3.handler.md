---
icon: fluent:target-24-regular
---

# Event Handler

> Event handler defines application logic.

After creating an [H3 App Instance](/guide/app), you can start defining your application logic using event handlers.

An event handler is a function that receives an [H3Event](/guide/event) context and returns a response.

> [!TIP]
> See possible return values in [Response Types](#responses-types)

## Defining Event Handlers

You can define typed event handlers using `defineEventHandler`.

> [!NOTE]
> Using `defineEventHandler` is optional. When using [app methods](/guide/app#h3-methods) to register routes or middleware, the type hints will be still available.

```js
import { defineEventHandler } from "h3";

defineEventHandler((event) => "Response");
```

The callback function can be sync or async:

```js
defineEventHandler(async (event) => "Response");
```

You can optionally register some [middleware](#middleware) to run with event handler to intercept request, response or errors.

```js
defineEventHandler({
  middleware: [basicAuth({ password: "test" })],
  handler: (event) => "Hi!",
});
```

## Error Handling

You can easily create standard HTTP errors using `HTTPError` with different syntaxes.

```js
import { HTTPError } from "h3";

app.get("/error", (event) => {
  // Using message and details
  throw new HTTPError("Invalid user input", { status: 400 });

  // Using HTTPError.status(code)
  throw HTTPError.status(400, "Bad Request");

  // Using single pbject
  throw new HTTPError({
    status: 400,
    statusText: "Bad Request",
    message: "Invalid user input",
    data: { field: "email" },
    body: { date: new Date().toJSON() },
    headers: {},
  });
});
```

This will end the request with `400 - Bad Request` status code and the following JSON response:

```json
{
  "date": "2025-06-05T04:20:00.0Z",
  "status": 400,
  "statusText": "Bad Request",
  "message": "Invalid user input",
  "data": {
    "field": "email"
  }
}
```

**Error Fields:**

- `status`: HTTP status code in range 200...599
- `statusText`: HTTP status text.
- `message`: HTTP Error message in JSON body.
- `unhandled`: Flag to indicate error was not handled by the application.
- `data`: Additional data to attach in the error JSON body under `data` key.
- `body`: Additional top level JSON body properties to attach in the error JSON body.
- `headers`: Additional HTTP headers to be sent in error response.
- `cause`: Original error object that caused this error. Very useful for tracing and debugging!

> [!IMPORTANT]
> Error `statusText` should be short (max 512 to 1024 characters) and only include tab, spaces or visible ASCII charactersand extended characters (byte value 128â€“255).

> [!NOTE]
> Any error that occurs during calling an event handler without using `HTTPError` will be processed as an "unhandled" error. H3 hides certain fields (`data`, `body` and `message`) in HTTP response for thiserrors for security reasons.

```js
app.get("/error", (event) => {
  // This will cause an unhandled error.
  throw new Error("Something went wrong");
});
```

## Lazy Handlers

You can define lazy event handlers using `defineLazyEventHandler`. This allow you to define some one-time logic that will be executed only once when the first request matching the route is received.

A lazy event handler must return an event handler.

```js
import { defineLazyEventHandler } from "h3";

defineLazyEventHandler(async () => {
  await initSomething(); // Will be executed only once
  return (event) => {
    return "Response";
  };
});
```

This is useful to define some one-time logic such as configuration, class initialization, heavy computation, etc.

Another use-case is lazy loading route chunks:

```js [app.mjs]
import { H3, defineLazyEventHandler } from "h3";

const app = new H3();

app.all(
  "/route",
  defineLazyEventHandler(() =>
    import("./route.mjs").then((mod) => mod.default),
  ),
);
```

```js [route.mjs]
import { defineEventHandler } from "h3";

export default defineEventHandler((event) => "Hello!");
```

## Middleware Handlers

You can register global middleware using [`app.use`](/guide/app#appuse) to intercept requests. They can be used to add side effects to your application such as logging, caching, etc or to modify the request or response.

If you return a value from middleware, it will act as a normal event handler and sent it as response.

**Example:** Simple request logger.

```js [log.mjs]
app.use((event) => {
  console.log(`[${event.req.method}] ${event.req.url}`);
});
```

**Example:** Intercept responses.

```js [intercept.mjs]
app.use(async (event, next) => {
  const rawResponse = await next();
  return rawResponse;
});
```

You can define as much middleware as you need. They will be called in order of registration.

:read-more{to="/guide/routing#adding-middleware"}

## Converting to H3 Handler

There are situations that you might want to convert an event handler or utility made for Node.js or another framework to h3.
There are built-in utils to do this.!

### Converting from Web Handlers

Request handlers with [Request](https://developer.mozilla.org/en-US/docs/Web/API/Request) => [Response](https://developer.mozilla.org/en-US/docs/Web/API/Response) syntax can be natively converted into H3 event handlers.

```js
import { H3, fromWebHandler } from "h3";

export const app = new H3();

const webHandler = (request) => new Response("ðŸ‘‹ Hello!"));

// Using fromWebHandler utiliy
app.get("/web", fromWebHandler(webHandler));

// Using simple wrapper
app.get("/web", event => webHandler(event.req));

// Using app.mount
app.mount("/web", webHandler)
```

:read-more{to="/guide/app#appmount" title="app.mount"}

### Converting from Node.js Handlers

If you have a legacy request handler with `(req, res) => {}` syntax made for Node.js, you can use `fromNodeHandler` to convert it to an h3 event handler.

> [!IMPORTANT]
> Node.js event handlers can only run within Node.js server runtime!

```js
import { H3, fromNodeHandler } from "h3";

// Force using Node.js compatibility (also works with Bun and Deno)
import { serve } from "h3/node";

export const app = new H3();

const nodeHandler = (req, res) => {
  res.end("Node handlers work!");
};

app.get("/web", fromNodeHandler(nodeHandler));
```

## Responses Types

Values returned from event handlers are automatically converted to HTTP response body.

If returned value from event handler is a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) or from an [async function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function), H3 will wait for it to resolve before sending the response.

### `null` or `undefined`

Sends a response with empty body in [route handlers](/guide/routing#adding-routes) or goes to next handler for [middleware handlers](/guide/routing#adding-middleware).

> [!TIP]
> If there is no `return` statement in event handler, it is same as `return undefined`.

### String

Returning a string value, sends it as plain text body.

> [!NOTE]
> If not setting `content-type`, it can default to `text/plain;charset=UTF-8`.

**Example:** Send HTML response

```ts
app.get("/", (event) => {
  event.res.headers.set("Content-Type", "text/html;charset=UTF-8");
  return "<h1>hello world</h1>";
});
```

### JSON Serializable Value

Returning a [JSON](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON) serializable value (**object**, **array**, **number** or **boolean**), it will be stringified using [JSON.stringiy()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify) and sent with default `application/json` content-type.

**Example:**

```ts
app.get("/", (event) => ({ hello: "world" }));
```

> [!TIP]
> You can add `toJSON()` method in object to customize serialization behavior. Check [MDN docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify) for more info.

### `Response`

Send a standard web [Response](https://developer.mozilla.org/en-US/docs/Web/API/Response/Response).

**Example:**

```ts
app.get("/", (event) => Response.json({ hello: "world" }));
```

> [!NOTE]
> When sending a `Response`, any headers that set using `event.res.headers` before, will be merged as default headers. `event.res.{status/statusText}` will be ignored.
> <br>
> For performance reasons, it is best to only set headers only from final `Response`.

### `ReadableStream` or `Readable`

Send a standard web [ReadableStream](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream) or node [Readable](https://nodejs.org/api/stream.html#readable-streams).

### `ArrayBuffer` or `Uint8Array` or `Buffer`

Send binary [ArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer), [Uint8Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array) or node [Buffer](https://nodejs.org/api/buffer.html#buffer).

`content-length` header will be automatically set.

### `Error`

Retuning an [Error](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error) instance will send it.

It is better to `throw` errors instead of returning them and using `createError` utility.

### `BigInt`

Value will be sent as stringified version of BigInt number.

> [!NOTE]
> Returning a JSON object, does not allows BigInt serialization. You need to implement `toJSON`. Check [MDN docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify) for more info.

### `Blob`

Send a standard web [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob) as stream.

`Content-type` and `Content-Length` headers will be automatically set.

### `File`

Send a standard web [File](https://developer.mozilla.org/en-US/docs/Web/API/File) as stream.

`Content-type`, `Content-Length` and `Content-Disposition` headers will be automatically set.

### `Symbol` or `Function`

Returning Symbol or Function has undetermined behavior. Current version sends a string-like representation of unknown Symbols and Functions but it might be changed to throw an error, never return them. There are some internal known Symbols h3 internally uses (can change in future):

- `Symbol.for("h3.notFound")`: Indicate no route is found to throw a 404 error.
- `Symbol.for("h3.handled")`: Indicate request is somehow handled and h3 should not continue (Node.js specific).
