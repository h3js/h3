---
icon: fluent:target-24-regular
---

# Event Handler

> Event handler defines application logic.

After creating an [h3 app instance](/guide/app), you can start defining your application logic using event handlers.

An event handler is a function that receives an [H3Event](/guide/event) context and returns a response.

## Defining Event handlers

You can define typed event handlers using `defineEventHandler`.

> [!NOTE]
> Using `defineEventHandler` is optional. When using [app methods](/guide/app#h3-methods) to register routes or middleware, the type hints will be still available.

```js
import { defineEventHandler } from "h3";

defineEventHandler((event) => "Response");
```

The callback function can be sync or async:

```js
defineEventHandler(async (event) => "Response");
```

### Object Syntax

You can use an object syntax in `defineEventHandler` for more flexible options.

```js
defineEventHandler({
  onRequest: [],
  onBeforeResponse: []
  handler: () => "Response",
})
```

## Responses Types

Values returned from event handlers are automatically converted to http response. It can be:

- [Response](https://developer.mozilla.org/en-US/docs/Web/API/Response/Response)
- [ReadableStream](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream) or [Readable](https://nodejs.org/api/stream.html#readable-streams) (node).
- [ArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer), [Uint8Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array) or [Buffer](https://nodejs.org/api/buffer.html#buffer) (node).
- `string`: Sent as-is using default text content-type.
- `null`: h3 with end response with `204 - No Content` status code.
- [JSON](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON) serializable object. It will be stringified using [JSON.stringiy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify) and sent with default `application/json` content-type.
- [Error](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error) instance. It is better to `throw` errors instead of returning them and using `createError` utility.

If returned value from event handler is a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) or from an [async function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function), h3 will wait for it to resolve before sending the response.

**Example:** Send text response:

```js
app.get("/text", () => "Hello world!");
```

**Example:** Send JSON response:

```js
app.get("/json", (event) => ({
  path: event.path,
  method: event.req.method,
}));
```

**Example:** Send a Web [Response](https://developer.mozilla.org/en-US/docs/Web/API/Response/Response):

```js
app.get("/web", () => {
  return new Response("<h1>Hello world!</h1>", {
    headers: { "content-type": "text/html" },
  });
});
```

**Example:** Using async functions:

```js
app.get("/async", async (event) => {
  await new Promise((resolve) => setTimeout(resolve, 500)); // Wait for 500ms
  return "response sent after 500ms";
});
```

## Error Handling

You can easily control the error returned by using the `createError` utility.

```js
import { createError } from "h3";

app.get("/error", (event) => {
  throw createError({
    status: 400,
    statusMessage: "Bad Request",
    message: "Invalid user input",
    data: { field: "email" },
  });
});
```

This will end the request with `400 - Bad Request` status code and the following JSON response:

```json
{
  "statusCode": 400,
  "statusMessage": "Bad Request",
  "stack": [],
  "data": {
    "field": "email"
  }
}
```

### String vs. Object Errors

When creating an error using `createError`, you also have the option to pass a string instead of an object. Doing so will set the `message` property of the error. In this case, the `statusCode` will default to `500`.

```js
import { createError } from "h3";

app.get("/error", (event) => {
  throw createError("An error occurred");
});
```

> [!TIP]
> Typically, `message` contains a brief, human-readable description of the error, while `statusMessage` is specific to HTTP responses and describes the status text related to the response status code.
> In a client-server context, using a short `statusMessage` is recommended because it can be accessed on the client side. Otherwise, a `message` passed to `createError` on the server will not propagate to the client (you can use `data` instead). Consider avoiding to put dynamic user input to the message to avoid potential security issues.

### Internal Errors

If during calling an event handler an error with `new Error()` will be thrown (without `createError`), h3 will automatically catch as a [`500 - Internal Server Error`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/500) status response considering it an unhandled error.

```js
app.get("/error", (event) => {
  // Do NOT do this and use createError()!
  throw new Error("Something went wrong");
});
```

## Lazy Handlers

You can define lazy event handlers using `defineLazyEventHandler`. This allow you to define some one-time logic that will be executed only once when the first request matching the route is received.

A lazy event handler must return an event handler:

```js
import { defineLazyEventHandler } from "h3";

app.get(
  "/lazy",
  defineLazyEventHandler(() => {
    console.log("This will be executed only once");
    // This will be executed only once
    return (event) => {
      // This will be executed on every request
      return "Response";
    };
  }),
);
```

This is useful to define some one-time logic such as configuration, class initialization, heavy computation, etc.

## Middleware Handlers

Event handlers that don't return any value act as middleware. They can be used to add side effects to your application such as logging, caching, etc or to modify the request or response.

Middleware handlers should be registered using `app.use()`. Event handlers in normal routes that do not return a value (e.g `app.get()`), will cause a 404 error.

If you return a value from middleware handlers, it will act as a normal event handler and sent it as response.

**Example:** Simple request logging middleware:

```js
app.use((event) => {
  console.log(`[${event.req.method}] ${event.req.url}`);
  // [do not return a value]
});
```

You can define as much middleware as you need. They will be called in order of registration.

:read-more{to="/guide/routing#adding-middleware"}

## Converting to H3 Handler

There are situations that you might want to convert an event handler or utility made for Node.js or another framework to h3.
There are built-in utils to do this.!

### Converting from Web Handlers

Request handlers with [Request](https://developer.mozilla.org/en-US/docs/Web/API/Request) => [Response](https://developer.mozilla.org/en-US/docs/Web/API/Response) syntax can be natively converted into h3 event handlers

```js
import { H3, fromWebHandler } from "h3";

export const app = new H3();

const webHandler = (request) => new Response("ðŸ‘‹ Hello!"));

// Using fromWebHandler utiliy
app.get("/web", fromWebHandler(webHandler));

// Using simple wrapper
app.get("/web", event => webHandler(event.req));
```

### Converting from Node.js handlers

If you have a legacy request handler with `(req, res) => {}` syntax made for Node.js, you can use `fromNodeHandler` to convert it to an h3 event handler.

> [!NOTE]
> Node.js event handlers can only run within Node.js server runtime!

```js
import { H3, fromNodeHandler } from "h3";

export const app = new H3();

const nodeHandler = (req, res) => {
  res.end("Node handlers work!");
};

app.get("/web", fromNodeHandler(nodeHandler));
```
