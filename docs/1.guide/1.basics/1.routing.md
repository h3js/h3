---
icon: solar:routing-bold
---

# Request Handling

> H3 has a built-in router that matches route patterns with parameters and HTTP methods.

## Request Lifecycle Overview

A Web Standard server is responsible for converting an incoming [Request](https://developer.mozilla.org/en-US/docs/Web/API/Request) into a final [Response](https://developer.mozilla.org/en-US/docs/Web/API/Response).
The âš¡ H3 core acts as a dispatcher and a minimal framework for handling requests and generating responses.

1. Incoming Request (runtime)
   - An HTTP request is made, server receives a [Request](https://developer.mozilla.org/en-US/docs/Web/API/Request) object.
2. Accepting Request ([`h3.fetch`](/guide/api/h3))
   - Initialize an [`H3Event`](/guide/api/h3event) instance from Request.
   - Call [`onRequest`](/guide/api/h3#global-hooks) global hook.
   - Call [`h3.handler`](/guide/api/h3#apphandler) with initialized event.
3. Dispatching Request ([`h3.handler`](/guide/api/handler))
   - Route is matched based on `request.url` and `request.method`.
   - Global middleware are called by order.
   - Matched route handler function is called with event.
4. Response Handling
   - Convert [returned response](/guide/basics/response) and prepared headers into standard [Response](https://developer.mozilla.org/en-US/docs/Web/API/Response).
   - Call [`onBeforeResponse`](/guide/api/h3#global-hooks) global hook.
   - Return generated Response to runtime for sending back to the client.

> [!NOTE]
> Global middleware are wrappers around main handler and can intercept request, response and errors. They looks like `middlewareA(middlewareB(handler(event)))`

> [!NOTE]
> â€‹ [ðŸ’¥ Srvx](/guide/node) Acts as a proxy for Web Standard compatibility in Node.js and unifies runtime specific context of other runtimes.

> [!NOTE]
> ðŸš€ H3 uses srvx `FastURL` internally instead of `new URL(req.url).pathname` to optimize route matching in fast paths.

## Routes

Each request is matched to one (most specific) route handler.

You can register route handlers to app instance using [`H3.on`](/guide/api/h3#h3on), [`H3.[method]`](/guide/api/h3#h3method), or [`H3.all`](/guide/api/h3#h3all).

> [!TIP]
> H3 Router is powered by [ðŸŒ³ Rou3](https://github.com/h3js/rou3), an ultra-fast and tiny route matcher engine.

**Example:** Register a route to match requests to the `/hello` endpoint with HTTP **GET** method.

- Using [`H3.[method]`](/guide/api/h3#h3method)

  ```js
  app.get("/hello", () => "Hello world!");
  ```

- Using [`H3.on`](/guide/api/h3#h3on)

  ```js
  app.on("GET", "/hello", () => "Hello world!");
  ```

You can register multiple event handlers for the same route with different methods:

```js
app
  .get("/hello", () => "GET Hello world!")
  .post("/hello", () => "POST Hello world!")
  .any("/hello", () => "Any other method!");
```

You can also use [`H3.all`](/guide/api/h3#h3all) method to register a route accepting any HTTP method:

```js
app.all("/hello", (event) => `This is a ${event.req.method} request!`);
```

### Dynamic Route Params

You can define dynamic route parameters using `:` prefix:

```js
// [GET] /hello/Bob => "Hello, Bob!"
app.get("/hello/:name", (event) => {
  return `Hello, ${event.context.params.name}!`;
});
```

Instead of named parameters, you can use `*` for unnamed **optional** parameters:

```js
app.get("/hello/*", (event) => `Hello!`);
```

### Wildcard Routes

Adding `/hello/:name` route will match `/hello/world` or `/hello/123`. But it will not match `/hello/foo/bar`.
When you need to match multiple levels of sub routes, you can use `**` prefix:

```js
app.get("/hello/**", (event) => `Hello ${event.context.params._}!`);
```

This will match `/hello`, `/hello/world`, `/hello/123`, `/hello/world/123`, etc.

> [!NOTE]
> Param `_` will store the full wildcard content as a single string.

## Middleware

Global middleware run on each request before route handler and act as wrappers to intercept request, response and errors.

You can register global [middleware](/guide/handler#middleware) to app instance using the [`H3.use`](/guide/api/h3#h3use).

> [!TIP]
> We recommend using composable utilities whenever possible. Global middleware can complicate application logic, making it less predictable and harder to understand.

**Example:** Register a global middleware that logs every request.

```js
app.use((event) => {
  console.log(event);
});
```

**Example:** Register a global middleware that matches certain requests.

```js
app.use(
  "/blog/**",
  (event, next) => {
    console.log("[alert] POST request on /blog paths!");
  },
  {
    method: "POST",
    // match: (event) => event.req.method === "POST",
  },
);
```

You can register middleware with `next` argument to intercept return values of next middleware and handler.

```js
app.use(async (event, next) => {
  const rawBody = await next();
  // [intercept response]
  return rawBody;
});
```

> [!IMPORTANT]
> If middleware returns a value other than `undefined` or the result of `next()`, it immediately intercepts request handling and sends a response.

Example below, always responsds with `Middleware 1`.

```js
app
  .use(() => "Middleware 1")
  .use(() => "Middleware 2")
  .get("/", "Hello");
```

When adding routes, you can register middleware that only run with them.

```js
import { basicAuth } from "h3";

app.get(
  "/secret",
  (event) => {
    /* ... */
  },
  {
    middleware: [basicAuth({ password: "test" })],
  },
);
```

For convenience, H3 provides middleware factory functions `onRequest`, `onResponse`, and `onError`:

```js
import { onRequest, onResponse, onError } from "h3";

app.use(
  onRequest((event) => {
    console.log(`[${event.req.method}] ${event.url.pathname}`);
  }),
);

app.use(
  onResponse((event, { body }) => {
    console.log(`[${event.req.method}] ${event.url.pathname} ~>`, body);
  }),
);

app.use(
  onError((event, error) => {
    console.log(
      `[${event.req.method}] ${event.url.pathname} !! ${error.message}`,
    );
  }),
);
```
